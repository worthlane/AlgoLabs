# Лабораторная работа 4 (Кучи)

## Пункт 0

Для начала нам нужно сгенерировать тесты, для того чтобы проверять сортировки. Напишем программу на Си, которая будет по данным в командной строке генерировать массив случайных чисел. Реализация этой программы хранится в файле ```arraygen.c```.

Как будем проверять валидность массива? Давайте в тестировании функции построения кучи будем проходиться по каждому элементу в массиве, и сравнивать его величину с величиной его левого и правого сына. Будем строить кучу на максимуме, то есть сыновья должны быть меньше родителя.

## Пункт 1

Реализуем две функции построения кучи.

1. Стандартное построение
2. Построение за линию

### Стандартное построение

#### Алгоритм

Пусть мы имеем массив, который нам нужно привести к виду кучи. Будем считать, что в начале мы имеем кучу из одного элемента (первого в массиве). Затем будем по очереди идти от начала массива к концу, поднимая каждый элемент внутри кучи с помощью функции ```SiftUp```. В таком случае пройдясь по каждому элементу, мы получим кучу, хранящуюся в нашем массиве.

#### Оценка времени

Добавление элемента в кучу происходит за время $O(\log{n})$. Имеем массив из $n$ элементов, каждый из которых мы должны добавить в кучу. Таким образом мы построим кучу за время $O(n \cdot \log{n})$.

### Построение за линию

#### Алгоритм

Можно построить быстрее. Можем представить, что в массиве итак хранится некая куча, которую нужно упорядочить. С помощью функции ```SiftDown``` будем спускать внутри кучи те вершины, которые имеют хотя бы одного сына (вершины с индексами от $\frac{n}{2}$ до $0$). Остальные же вершины, образующие поддеревья из одного элемента, можно считать уже упорядоченными.

#### Оценка времени

Число вершин на уровне $h$ в куче из $n$ элементов не более чем $\lceil \frac{n}{2^h} \rceil$. В таком случае построение будет работать не более чем за:

$$ T(n) = \sum_{i = 2}^{h}{\frac{n}{2^{i}}} = O(n) \cdot \sum_{i = 1}^{h}{\frac{i}{2^i}} = const \cdot O(n) = O(n).$$

Мы начинаем сумму с $i = 2$ так как не имеет смысла рассматривать самый нижний уровень кучи, как было описано ранее.

### Сравнение построений

Запустим построение куч на тестовых массивах, длины от $10^5$ до $10^6$. Засекать время будем как среднее за несколько тестов. Таким образом можем построить график времени выполнения от длины массива, выглядеть он будет таким образом:

| ![](pictures/heapify.png) |
|:-------------------------:|
| [Рис. 1] Сравнение скорости разных построений кучи |

Заметно, что линейный вариант построения работает заметно быстрее. Узнаем насколько он быстрее, аппроксимировав линии на графике как прямые, и сравнив их угловые коэффициенты.

$$k_{std} = \frac{(200 - 20) \cdot 10^{-4}}{(10 - 1) \cdot 10^5} \approx 20 \cdot 10^{-9};$$
$$k_{lin} = \frac{(127 - 20) \cdot 10^{-4}}{(10 - 1) \cdot 10^5} \approx 12 \cdot 10^{-9};$$
$$coef = \frac{k_{std}}{k_{lin}} \approx 1.67.$$

Таким образом, способ построения за линию быстрее примерно в 1.7 раз.

## Вывод

Подводя итоги эксперименту, можно сделать вывод, что для построения бинарной кучи более подходит способ построения за линию, так как он работает быстрее при любом размере кучи.
